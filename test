import discord
from discord.ext import commands
from discord import app_commands
import aiosqlite
from datetime import datetime, timezone

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True

bot = commands.Bot(command_prefix='/', intents=intents)

GUILD_ID = 1252250439194247310
CATEGORY_ID = 1254727085633830993
STAFF_ROLE_ID = 1254725666801324124

class TicketModal(discord.ui.Modal, title='Create Ticket'):
    description = discord.ui.TextInput(label='Description', style=discord.TextStyle.long, placeholder='Describe your issue...', required=True)
    
    async def on_submit(self, interaction: discord.Interaction):
        user_id = interaction.user.id
        description = self.description.value
        guild = interaction.guild
        category = guild.get_channel(CATEGORY_ID)
        
        # Create a private text channel for the ticket
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False),
            guild.get_role(STAFF_ROLE_ID): discord.PermissionOverwrite(read_messages=True),
            interaction.user: discord.PermissionOverwrite(read_messages=True)
        }
        channel = await category.create_text_channel(name=f'ticket-{interaction.user.name}', overwrites=overwrites)
        
        async with aiosqlite.connect('worktime.db') as db:
            await db.execute('INSERT INTO tickets (user_id, channel_id, status, description, created_at) VALUES (?, ?, ?, ?, ?)',
                             (user_id, channel.id, 'open', description, datetime.now(timezone.utc)))
            await db.commit()
        
        await channel.send(f'Ticket created by {interaction.user.mention}\n\nDescription: {description}')
        await interaction.response.send_message('Your ticket has been created.', ephemeral=True)

async def init_db():
    async with aiosqlite.connect('worktime.db') as db:
        await db.execute('''
            CREATE TABLE IF NOT EXISTS worktime (
                user_id INTEGER PRIMARY KEY,
                start_time TEXT,
                end_time TEXT,
                total_time INTEGER
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS tickets (
                ticket_id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                channel_id INTEGER,
                status TEXT,
                description TEXT,
                created_at TEXT,
                closed_at TEXT
            )
        ''')
        await db.commit()

@bot.event
async def on_ready():
    await init_db()
    try:
        await bot.tree.sync()  # Sync globally
        await bot.tree.sync(guild=discord.Object(id=GUILD_ID))  # Sync specifically to the guild
        print(f'Synced commands')
    except Exception as e:
        print(f'Failed to sync commands: {e}')
    print(f'Logged in as {bot.user}')

@bot.tree.command(name="fichar", guild=discord.Object(id=GUILD_ID))
async def _fichar(interaction: discord.Interaction):
    user_id = interaction.user.id
    async with aiosqlite.connect('worktime.db') as db:
        cursor = await db.execute('SELECT start_time, end_time, total_time FROM worktime WHERE user_id = ?', (user_id,))
        row = await cursor.fetchone()

        if row is None or row[1] is not None:  # If not working, start working
            await db.execute('REPLACE INTO worktime (user_id, start_time, end_time, total_time) VALUES (?, ?, ?, ?)',
                             (user_id, datetime.now(timezone.utc), None, row[2] if row else 0))
            await interaction.response.send_message('You are now marked as working.', ephemeral=True)
        else:  # If already working, stop working
            start_time = datetime.fromisoformat(row[0])
            end_time = datetime.now(timezone.utc)
            total_time = (end_time - start_time).seconds + row[2]
            await db.execute('UPDATE worktime SET end_time = ?, total_time = ? WHERE user_id = ?',
                             (end_time, total_time, user_id))
            await interaction.response.send_message('You are now marked as not working.', ephemeral=True)

        await db.commit()

@bot.tree.command(name="worktime", guild=discord.Object(id=GUILD_ID))
@app_commands.checks.has_permissions(administrator=True)
async def _worktime(interaction: discord.Interaction, user: discord.User):
    user_id = user.id
    async with aiosqlite.connect('worktime.db') as db:
        cursor = await db.execute('SELECT total_time FROM worktime WHERE user_id = ?', (user_id,))
        row = await cursor.fetchone()

        if row:
            total_hours = row[0] // 3600
            total_minutes = (row[0] % 3600) // 60
            await interaction.response.send_message(f'{user.mention} has worked for {total_hours} hours and {total_minutes} minutes.', ephemeral=True)
        else:
            await interaction.response.send_message(f'{user.mention} has no recorded work time.', ephemeral=True)

@bot.tree.command(name="cleardb", guild=discord.Object(id=GUILD_ID))
@app_commands.checks.has_permissions(administrator=True)
async def _cleardb(interaction: discord.Interaction):
    async with aiosqlite.connect('worktime.db') as db:
        await db.execute('DELETE FROM worktime')
        await db.commit()
    await interaction.response.send_message('The database has been cleared.', ephemeral=True)

@bot.tree.command(name="dump", guild=discord.Object(id=GUILD_ID))
@app_commands.checks.has_permissions(administrator=True)
async def _dump(interaction: discord.Interaction):
    async with aiosqlite.connect('worktime.db') as db:
        cursor = await db.execute('SELECT user_id, total_time FROM worktime')
        rows = await cursor.fetchall()

        if not rows:
            await interaction.response.send_message('No work records found.', ephemeral=True)
            return

        report = "Worker Summary:\n\n"
        for row in rows:
            user = await bot.fetch_user(row[0])
            total_hours = row[1] // 3600
            total_minutes = (row[1] % 3600) // 60
            report += f'{user.name}#{user.discriminator} has worked for {total_hours} hours and {total_minutes} minutes.\n'

        await interaction.response.send_message(report, ephemeral=True)

# Ticket system commands
@bot.tree.command(name="create_ticket", guild=discord.Object(id=GUILD_ID))
async def _create_ticket(interaction: discord.Interaction):
    await interaction.response.send_modal(TicketModal())

@bot.tree.command(name="close_ticket", guild=discord.Object(id=GUILD_ID))
async def _close_ticket(interaction: discord.Interaction, ticket_id: int):
    user_id = interaction.user.id
    async with aiosqlite.connect('worktime.db') as db:
        cursor = await db.execute('SELECT channel_id, status FROM tickets WHERE ticket_id = ? AND user_id = ?', (ticket_id, user_id))
        row = await cursor.fetchone()

        if row and row[1] == 'open':
            await db.execute('UPDATE tickets SET status = ?, closed_at = ? WHERE ticket_id = ? AND user_id = ?',
                             ('closed', datetime.now(timezone.utc), ticket_id, user_id))
            await db.commit()

            # Delete the channel
            channel = interaction.guild.get_channel(row[0])
            if channel:
                await channel.delete()

            await interaction.response.send_message('Your ticket has been closed.', ephemeral=True)
        else:
            await interaction.response.send_message('Ticket not found or already closed.', ephemeral=True)

@bot.tree.command(name="manage_tickets", guild=discord.Object(id=GUILD_ID))
@app_commands.checks.has_permissions(administrator=True)
async def _manage_tickets(interaction: discord.Interaction):
    async with aiosqlite.connect('worktime.db') as db:
        cursor = await db.execute('SELECT ticket_id, user_id, channel_id, status, description, created_at, closed_at FROM tickets')
        rows = await cursor.fetchall()

        if not rows:
            await interaction.response.send_message('No tickets found.', ephemeral=True)
            return

        report = "All Tickets:\n\n"
        for row in rows:
            user = await bot.fetch_user(row[1])
            report += (f'Ticket ID: {row[0]}\nUser: {user.name}#{user.discriminator}\nStatus: {row[3]}\n'
                       f'Description: {row[4]}\nCreated At: {row[5]}\nClosed At: {row[6] if row[6] else "N/A"}\n'
                       f'Channel: <#{row[2]}>\n\n')

        await interaction.response.send_message(report, ephemeral=True)
